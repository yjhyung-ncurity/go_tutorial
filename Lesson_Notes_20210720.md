### Slice Range Syntax
- example: sample['a','b','c','d'] 
    - sample[start_index_inclusive : up_to_index_not_inclusive]
    - sample[0:2] 
        - starts from 0 index which is 'a' and ends before 2 index which is 'c'
        - returns 'a', 'b' only
    - sample[1:3]
        - starts from 1 index which is 'b' and ends before 3 index which is 'd'
        - returns 'b','c'
    - sample[:3]
        - starts from the beginning index which is 'a' and ends before 2 index which is 'd'
        - returns 'a','b','c'
    - sample[2:]
        - starts from 2 index which is 'c' and ends at the last index which is 'd'
        - returns 'c' , 'd'


### Byte Slice
 - List of bytes that represent UTF-8 encodings of Unicode Code points (See: ASCII TABLE Site)
 - ex) bs := []byte{71, 111} 
       fmt.Printf("%s", bs)
       %s converts byte slice to string 

### Byte Slice Type Conversion
 - Use []byte()
 - ex) greeting := "Hi There!" 
       fmt.Println([]byte(greeting))

 ### REF1 : https://jacking75.github.io/go_slice_array/
 ### REF2 : https://medium.com/@tyler_brewer2/bits-bytes-and-byte-slices-in-go-8a99012dcc8f

### IO/IOUTIL PACKAGE - WriteFile function (saving files to the hard drive)
 - As an example, created saveToFile function which includes the following:
    - receiver of a deck type (custom type)
    - argument of a filename (input parameter)
    - return type of error (error message)

 - ioutil.WriteFile(filename, []byte(d.toString()), 0666) 
    - writeFile arguments checkout golang/pkg/ioutil@go1.16.6#WriteFile

### Random Value 
 - rand.Intn : Pseudo Random Generator (Seed value is the set of values which needs to be generated by generator. Pseu Generator always uses the same seed to generate random number)
 - that's why it always provides the same random value 
 - How to create random numbers each time?
    - provide random seed numbers each time by using type Rand


### Testing with Go 
 - To make a test file, create a new file and name has to ends in _test.go (ex. testing main file. => main_test.go)
 - To run test, use `go test` command
 - Excercise #1 : new deck function by using if statement and errorf in TestNewDeck() to test the following :
    - To make sure deck is created with x number of cards (ex. 4 suits, 4 numbers = total of 16 cards)
    - To make sure the first card is an Ace of Spades
    - To make sure that the last card is Four of Clubs 

 - Excercise #2 : save to file function and new deck from file function by using if statement and errorf in TestSaveToDeckAndNewDeckFromFile() to test the following :
    - To make sure if there is any crashed files
    - Use Remove() within os package provided by Go to remove any of the unnecessary / crashed files (ex. _decktesting)
    - Create a new deck and save it to a file by using SaveToFile function (ex. _decktesting)
    - Load the file by using NewDeckFromFile function (ex. _decktesting)
    - Make sure if the length of newly loaded file matches x number of cards (total of 16). if not return error message
    - Final step use Remove() again to remove files (ex. _decktesting)

### Review LECTURE 1 ~ 3
 - import : when importing more than one packages use parentheses and no commas in between
 - purpose of deck.go excercise
    - to describe what a deck is and it's behavior by first creating a type called 'deck' which is an abstract form of datatypes matched which in this case it would be []string (slice of string)
        - ex) NewDeck() deck : when called, immediately creates a set of deck and return it in 'deck' type form 
    - receiver function is a function that accepts a receiver. 
        - ex) (d deck) Print() : added a receiver right before the function name so any deck can call the Print function 
        
 - Things to Consider : 
    - why structured deal() function does not use receiver? 
    - t *testing.T 


## LECTURE 4 - STRUCTS DATA TYPE
### 1. What is Struct?
    - Data structure in Go. 
    - Collection of properties that are related together
    - Create a struct and assign more than one fields (data type)
        - ex) Struct type of Card 
        - ex) Fields : suit(string data type) , value(string data type)
    - Similar to :
        - Js: plain object , Ruby: hash , Python : dictionary 

### 2. Steps / Procedures
    - 1) Define a struct (initialize)
        - ex) type person struct { firstName string lastName string}
    - 2) Declare a struct (give values)
        - Ways to declare : 
            - 1. maps with defined struct based on the order of the fields (Go automatically assumes the order)
                - ex) alex := person("Alex", "Andersen")
                - cannot change the order of the field defined - if the two is swapped then Alex is mapped as lastName 
            - 2. specifically map the values with the field defined above
                - ex) alex := person(firstName: "Alex" , lastName: "Andersen")
            - 3. create a variable with struct data type assign a zero Value 
        - How to update the properties/fields of a struct ?
            - Underneath the declaration of variable and then .. 
                - ex) alex.firstName , alex.lastName

### 3. Embedding Struct within a Struct 
    - ex) 1st Struct type Person holds 3 fields : firstName (string), lastName (string) and contact (contactInfo)
    -     2nd Struct type ContactInfo holds 2 fields : email (string), zipcode (int) and have this two fields be sent to 1st Struct's contact field
    - when declaring a value to a property(field), every property(field) has to end with comma

### 4. Creating receiver using struct && Struct with Pointers
    - use person type as a receiver to print out the details of that person 
    - use person type as a receive to update that person's firstName (need to use pointers otherwise it will print out the initial value not the changed value)
        - REMINDER : although the value might have changed,since the changed value is not stored in the same address that have initial value

### 5. Pointer Operations:
    - & operator : Gives the access to the memory (RAM) address of the value this variable is pointing at
    - * operator : Gives the value this memory(RAM) address is pointing at
            - Difference between : 
                - Astrix infront of a type: (ex. pointerToPerson *person) is a type description. It means that the function can only be called with a receiver of this certain type

                - Astrix infront of an actual pointer: (ex. *pointerToPerson) is an actual operator which takes a pointer and turns it into a value. 

### 6. Pointer Shortcut 
    - Two ways to use pointer:
        - 1) get the memory access from the variable(ex. jim) by using & operator infront of the variable (ex. &jim) and use pointer as a receiver (ex. jimPointer.updateName("James") instead of jim.updateName("James"))
        - 2) (shortcut version) just use value (ex. jim.updateName("James"))
    
### 7. Gotchas with Pointers (Slice update vs. Struct update)
    - Slice : it automatically changes the element because it is _reference type_
    - Struct : it does not show the changed value because it is a _value type_

### 8. Reference Types vs. Value Types
    - Reference Type : 
        - Slices , Maps , Channels , Pointers , Functions
    - Value Type :
        - Int , Float , String , Bool , Structs



## LECTURE 5

### 1. What is a Map?

            






